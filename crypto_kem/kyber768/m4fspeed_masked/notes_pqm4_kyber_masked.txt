
#define NSHARES 2
#define COEF_NBITS 12

#define BSSIZE 32

typedef uint32_t BsBBit[NSHARES]; // dense
typedef BsBBit BsBCoef[COEF_NBITS]; // dense
typedef Coef int16_t;
typedef Coef ACoef[NSHARES]; // dense
typedef ACoef APoly[KYBER_N]; // dense
typedef APoly APolyVec[KYBER_K]; // dense
typedef StrAPoly Coef[NSHARES][KYBER_N]; // strided
typedef StrAPoly StrAPolyVec[KYBER_K]; // strided

------------

KEM
    input: ciphertext not masked (bytes) -> unpack to polynomials -> NTT
    input: key masked K polynomials -> representation strided (stored in NTT form)
    - mul keys with ciphertexts and add ciphertext -> sharewise outer loop
    - map state (A strided, not BS) to (A dense, not BS)
    - compress
        - for each group of 32 coefs:
            - for each share:
                - for each coef, mul with const, write-back (uint32_t)
                - map to BS (dense, BS)
            - BS A2B
            - write-back ciphertext buffer (masked BS, dense)
    - CPA.Enc
        - compute sigma (BS dense)
        - decompress ciphertext: extract each ciphertext bit -> arithm. masked, not BS, dense
        - wirte-back to strided poly
        - loop to generate r:
            - run PRF (output: BS dense)
            - for each coef: extract bits, run CBD -> arithmetic, not BS, dense
            - write-back coef to strided poly
        - r = NTT(r): only first share
        - for each poly in u:
            - Gen row of A, mul row of a with first share of r, apply NTT^-1
            - run PRF for e1, output: BS dense
            - for each coef of e1: extract bits, run CBD -> arithmetic, not BS, dense
            - write-back coef e1 to strided poly
            - add e1 to get u (strided arith.)
            - u to (BS, dense)
            - compress u -> c_u (BS, dense)
            - compare & AND to current "Ok" state (BS, dense)
        - idem for v
        - horizontally AND "Ok" state to single masked bit, refresh and unmask
        - run KDF (unmasked)

